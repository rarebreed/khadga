<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learn how to create a web app with rust and webassembly</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="expanded "><a href="chapter2/chapter_2.html"><strong aria-hidden="true">2.</strong> Setup</a></li><li><ol class="section"><li class="expanded "><a href="chapter2/chapter_2_1.html"><strong aria-hidden="true">2.1.</strong> Setting up the Project</a></li><li class="expanded "><a href="chapter2/chapter_2_2.html"><strong aria-hidden="true">2.2.</strong> Intro to kubernetes</a></li><li class="expanded "><a href="chapter2/chapter_2_3.html"><strong aria-hidden="true">2.3.</strong> Quickstart for minikube, kubectl and gcloud</a></li></ol></li><li class="expanded "><a href="chapter3/chapter_3.html"><strong aria-hidden="true">3.</strong> Frontend Single Page App</a></li><li><ol class="section"><li class="expanded "><a href="chapter3/chapter_3_1.html"><strong aria-hidden="true">3.1.</strong> React and State management</a></li><li class="expanded "><a href="chapter3/chapter_3_2.html"><strong aria-hidden="true">3.2.</strong> Navbar component</a></li><li class="expanded "><a href="chapter3/chapter_3_3.html"><strong aria-hidden="true">3.3.</strong> Login component</a></li></ol></li><li class="expanded "><a href="chapter4/chapter_4.html"><strong aria-hidden="true">4.</strong> Mongo Database</a></li><li><ol class="section"><li class="expanded "><a href="chapter4/chapter_4_1.html"><strong aria-hidden="true">4.1.</strong> Using docker</a></li><li class="expanded "><a href="chapter4/chapter_4_2_md.html"><strong aria-hidden="true">4.2.</strong> Docker copose</a></li><li class="expanded "><a href="chapter4/chapter_4_3.html"><strong aria-hidden="true">4.3.</strong> Schemas</a></li><li class="expanded "><a href="chapter4/chapter_4_4.html"><strong aria-hidden="true">4.4.</strong> Mongodb driver</a></li></ol></li><li class="expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Security</a></li><li><ol class="section"><li class="expanded "><a href="chapter5/chapter_5_1.html"><strong aria-hidden="true">5.1.</strong> Registering a user</a></li><li class="expanded "><a href="chapter5/chapter_5_2.html"><strong aria-hidden="true">5.2.</strong> TLS Certs</a></li><li class="expanded "><a href="chapter5/chapter_5_3.html"><strong aria-hidden="true">5.3.</strong> HTTPS in warp</a></li><li class="expanded "><a href="chapter5/chapter_5_4.html"><strong aria-hidden="true">5.4.</strong> Authentication</a></li><li class="expanded "><a href="chapter5/chapter_5_5.html"><strong aria-hidden="true">5.5.</strong> Authorization and JWTs</a></li></ol></li><li class="expanded "><a href="chapter6/chapter_6.html"><strong aria-hidden="true">6.</strong> Backend Server</a></li><li class="expanded "><a href="chapter7/chapter_7.html"><strong aria-hidden="true">7.</strong> Webassembly</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Learn how to create a web app with rust and webassembly</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction-to-khadga" id="introduction-to-khadga">Introduction to khadga</a></h1>
<p>This book is a small guide on how to create a web application using react, typescript, and
webassembly generated from rust.  It will take you from knowing nothing about how to create wasm to
how to generate both the front and back end code for your app.</p>
<p>The application that is generated here is a small chat application that will set up WebSocket
connections between two or more clients and the central web server.</p>
<p>If you're wondering where the name khadga comes from, it's a Sanskrit word meaning sword.  It is
often referred to in spiritual or mystical concepts as the sword that cuts away illusion.</p>
<h2><a class="header" href="#why" id="why">Why?</a></h2>
<p>One might ask why go through this?  If the main point of this app is to do a chat application with
video, there's a dime-a-dozen ready made apps for that.</p>
<p>Basically, I wanted to write a non-trivial application from top to bottom.  A truly <em>full-stack</em>
application where the front end, the back end, the database, the CI deployments, integration with
IoT sensor data, and the data analysis is all done by one developer (that'd be me, and hopefully you
the reader as well).</p>
<p>Yes, it's a tall order.  Although the primary purpose is to use this project as a vehicle for
learning how to do deep learning, my intention is to use khadga as a learning tool.  Not just for
myself but for others as well.  What I have learned is that most books don't walk you through a
non-trivial project from beginning to end.  Or, they might show you how to use some framework, but
not always why.</p>
<p>My hope is that by me forging ahead and suffering the learning pains, others can follow along and
avoid the mistakes I made.  Because of the pedantic nature of this project, I will endeavor to do
the following:</p>
<ul>
<li>Write documentation for all my code</li>
<li>Keep this book up to date</li>
<li>Show you every step of building a project (as much as possible)
<ul>
<li>Writing unit and integration tests</li>
<li>Using CI/CD to build, test, and deploy an application (on openshift)</li>
</ul>
</li>
<li>Try not to cut corners (ie, I will try to use <code>.unwrap()</code> or <code>.expect()</code> as little as I can)</li>
</ul>
<h2><a class="header" href="#what-you-will-learn" id="what-you-will-learn">What you will learn</a></h2>
<p>This guide will walk you through everything required to develop, test and deploy both the front and
backend application. This includes:</p>
<ul>
<li>How to write an asynchronous web server using rust's warp framework</li>
<li>How to use wasm-bindgen, web-sys and js-sys crates to create a wasm npm module and publish it</li>
<li>How to serve your single page app from the async web server</li>
<li>How to create a react+redux front end, using WebRTC and WebSockets modules written in webassembly</li>
<li>How to deploy your app to Openshift Online using docker</li>
<li>How to set up unit and integration tests for the front and back end</li>
<li>How to set up a CI pipeline between your deployment and your tests using travis-ci</li>
</ul>
<h3><a class="header" href="#what-the-app-does" id="what-the-app-does">What the app does</a></h3>
<p>We will build the functionality of the app slowly in order to make it useful early on, but to build
up functionality as we go.</p>
<ul>
<li>Chat application</li>
<li>WebRTC for cam-to-cam video conferencing</li>
<li>Video recognition</li>
</ul>
<p>First, we will start with a relatively simple chat application.  It will also cover things like
setting up a database of users and saved chat history.  It will also showcase how to do user
authentication and authorization.</p>
<p>Next, we will write a webassembly module that interacts with WebRTC and WebSocket APIs.  We will use
this so that the webassembly can quickly and efficiently store data into tensor format that we can
hand back to tensorflowjs.</p>
<p>Then, we will enhance the app so that it will do video as well as text based chatting.  In this
step, we will add a signaling service to the bacnd, so peers can find one another.  Chats can either
be saved locally or stored on the discovery server. This step will also show how to encrypt the
streams for end to end encryption.</p>
<p>Lastly, we will build on the video streams enabled by the WebRTC to do image recognition.  We will
use this as a project to detect faces that are displayed and see if it is a known user.</p>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<p>This chapter will cover how to scaffold and generate the initial wasm-pack code as well as a basic
asynchronous web server but it assumed that the reader is already familiar with:</p>
<ul>
<li>basic rust</li>
<li>basic html</li>
<li>basic css</li>
<li>basics of docker</li>
</ul>
<p>The reader's rust skills should be at a basic level.  One of the goals of the book is to explain
some of the more tricky rust concepts (or at least tricky to the author).  A basic understanding of
rust ownership and lifetimes, and how closures work will be required.  Understanding how Traits
work, especially AsRef and From/Into will also be useful. The async/await portions will be described
in detail however.</p>
<p>The reader should have a basic level of HTML5 understanding.  This includes knowing what the DOM is
and the basics of common tags.  Most of the front end will be calling the web-sys bindings to the
Web APIs, so it is useful but not required to know javascript.  Because we are creating a single
page app, knowledge of CSS will be useful, as the book will not spend a lot of time explaining much
of the CSS content.</p>
<p>For deployment, we will be using Openshift Online.  There is a free tier available and you can use
this to deploy the application.  In order to get the server to the cloud, we will need to create a
container and therefore a docker image. This will not be advanced, but there will not be a lot of
explanation of what the docker file does.</p>
<h2><a class="header" href="#caveats" id="caveats">Caveats</a></h2>
<p>The biggest caveat is the author is new to this himself.  The decision to write the book was to help
others so they do not have to learn the hard way like the author did.  Also, the author is at a
basic to intermediate level understanding of rust.  There could very well be a better way to write
the code and if so, please make a PR and contribute!</p>
<p>The second caveat was that this project made an opinionated stance on the technology used.  First
and foremost was the desire to use the new async/await syntax.  This lead to several <em>problems</em>.
For example, since async/await is still new, documentation is scarce.</p>
<h3><a class="header" href="#why-not-yew" id="why-not-yew">Why not yew?</a></h3>
<p>Seasoned developers might ask why <a href="https://github.com/yewstack/yew">yew</a> was not used for this project.  The simple answer here
is that there was a desire to use wasm-bindgen, web-sys and js-sys crates to create the app.</p>
<p>The author has no working knowledge of yew, and it was considered initially.  Afterall, it seems to
tick off a lot of the right boxes:</p>
<ul>
<li>Built in virtual DOM</li>
<li>Macros to generate JSX like code</li>
<li>Concurrency</li>
<li>Safe state management</li>
</ul>
<p>However, yew is built on a crate called stdweb instead of wasm-bindgen, web-sys and js-sys.  The
main difference is that those libraries are created and maintained by the official Web Assembly
Working Group.  It will therefore be more up to date and have &quot;official&quot; support.  It was also
designed to be language agnostic and the bindings are auto-generated from the WebIDL schema.</p>
<h3><a class="header" href="#why-not-percy" id="why-not-percy">Why not percy?</a></h3>
<p>There is another framework that looked promising called <a href="https://github.com/chinedufn/percy">percy</a>.  It also has a virtual DOM
and macro generator to create some JSX-like code. Unlike yew, it is using wasm-bindgen and web-sys
and js-sys crates. The problem with percy is that because of some of the macros, it required a
nightly toolchain.</p>
<p>Although nightly is great for individual learning and experimentation, it's not the best for
teaching others.  The brittleness of nightly means that what may compile one day for one person may
not compile for another person (or the same person!) on another day.  It can also be hard sometimes
to find a nightly build that allows all dependency crates to be built successfully.</p>
<h3><a class="header" href="#why-not-seed" id="why-not-seed">Why not seed?</a></h3>
<p>I discovered <a href="https://seed-rs.org/">seed</a> very recently, and while it seems to fit the bill for writing the entire
application in rust, upon some consideration, I felt that it would be more beneficial to write the
front end in react and typescript, and use wasm only for speed (or safety) sensitive areas of the
code.</p>
<p>This also has the advantage of being able to slowly convert existing applications to use wasm,
rather than have an all-in-one greenfield project created from scratch.</p>
<h1><a class="header" href="#local-setup" id="local-setup">Local Setup</a></h1>
<p>Now that you know what you will be building, let's get started setting up all the development
dependencies.  You'll need to have rust and npm set up as well as a few cargo tools</p>
<ul>
<li>rustup</li>
<li>npm (recommend using nvm)</li>
<li>cargo-generate</li>
<li>cargo-edit</li>
</ul>
<p>You can also checkout the github repository of khadga itself</p>
<h2><a class="header" href="#installing-rustup" id="installing-rustup">Installing rustup</a></h2>
<p>If you haven't already, install <a href="https://rustup.rs/">rustup</a> by following the directions.  If you
already have rustup installed, make sure it's at the latest and greatest (at the time of writing,
this is 1.40).  To update your rustup, do</p>
<pre><code class="language-bash">rustup self update
rustup update
</code></pre>
<p>Next, you need to set up the wasm32 target so that rustc can compile to the wasm32-unknown-unknown
target triple</p>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<h3><a class="header" href="#other-rustup-goodies" id="other-rustup-goodies">Other rustup goodies</a></h3>
<p>While we are configuring rustup, we can install some other components as well</p>
<pre><code class="language-bash">rustup component add llvm-tools-preview rustfmt clippy rls rust-analysis
</code></pre>
<h3><a class="header" href="#c-toolchain" id="c-toolchain">C(++) toolchain</a></h3>
<p>Some rust crates have native dependencies.  For example the openssl crate will use and link to a
native ssl lib on your system.  Because of this, it's sometimes necessary to have a C(++) toolchain
on your system as well.</p>
<p>It's beyond the scope of this book to show how to do this, since each operating system will do it a
bit differently.  For Windows, it's recommended to install one of the free Visual Studio C++
compilers.  For linux debian based distributions, you can usually get away with something like this:</p>
<pre><code class="language-sh">sudo apt install build-essential
</code></pre>
<p>For Fedora, you can do this:</p>
<pre><code class="language-sh">sudo dnf groupinstall &quot;Development Tools&quot;
sudo dnf groupinstall &quot;C Development Tools and Libraries&quot;
</code></pre>
<h2><a class="header" href="#adding-cargo-tools" id="adding-cargo-tools">Adding cargo tools</a></h2>
<p>Although cargo is automatically installed by rustup, we are going to install some cargo additions.</p>
<pre><code class="language-sh">cargo install cargo-generate cargo-edit
</code></pre>
<p>cargo-generate is a tool that will auto generate a template for you (and is used by wasm-pack) and
cargo-edit is a nice little cargo command that lets you add a dependency to your Cargo.toml (think
npm install).</p>
<h2><a class="header" href="#setting-up-vscode" id="setting-up-vscode">Setting up vscode</a></h2>
<p>We'll be using the Microsoft VS Code editor, since it has good support for rust and is relatively
lightweight.  Because we are using some bleeding edge crates, we'll also have to specify some
additional configuration in the rust extension.</p>
<p>First, install <a href="https://code.visualstudio.com/">vs code</a> itself.  Once you have code installed, we need to install
the rust extension. You can either do this from the command line, or through VS Code itself.</p>
<pre><code class="language-sh">code --install-extension rust-lang.rust
</code></pre>
<p>While we are installing extensions, let's install a couple others that will make our lives easier:</p>
<ul>
<li>crates: To make it easier to see what the latest (stable) crate version is at</li>
<li>lldb debugger: So we can debug our code</li>
<li>toml: so we can get syntax highlights and coloring for our toml files</li>
</ul>
<pre><code>code --install-extension bungcip.better-toml
code --install-extension vadimcn.vscode-lldb
code --install-extension serayuzgur.crates
</code></pre>
<h2><a class="header" href="#install-npm-and-nvm" id="install-npm-and-nvm">Install npm (and nvm)</a></h2>
<p>Since we are building a front end web app, we will be making use of some npm tools.  It's highly
recommended that you use the Node Version Manager (nvm) for this if you are on linux or MacOS.  For
windows users, you'll probably need to use chocolatey to install node (and npm).</p>
<h3><a class="header" href="#linux-and-macos" id="linux-and-macos">linux and macos</a></h3>
<p>For linux and macos users, you can follow the directions here to install nvm.  Once you install nvm,
you'll need to actually install a node version.</p>
<pre><code class="language-bash">nvm install 13
nvm use 13
</code></pre>
<h3><a class="header" href="#windows" id="windows">Windows</a></h3>
<p>For windows users, if you don't have <a href="https://chocolatey.org/install">chocolatey</a> already, install that.  Then you can
install node (and therefore npm) with:</p>
<pre><code class="language-bash">choco install nodejs  # make sure you run from an elevated command/powershell shell
</code></pre>
<h2><a class="header" href="#installing-wasm-pack" id="installing-wasm-pack">Installing wasm-pack</a></h2>
<p>For this project, we will be using wasm-pack which will generate a template for us, as well as set
up a webpack config which will automatically compile our rust code to wasm.</p>
<p>You can install <a href="https://rustwasm.github.io/wasm-pack/">wasm-pack</a> here.</p>
<p>Alternatively, you can install wasm-pack via cargo:</p>
<pre><code class="language-sh">cargo install wasm-pack
</code></pre>
<h1><a class="header" href="#setting-up-the-project" id="setting-up-the-project">Setting up the project</a></h1>
<p>Now that we have all our dependencies out of the way, it's time to actually create our project.
Unlike many rust projects you will see on tutorials, we are going to have a fairly advanced cargo
setup.  We will be using a feature of cargo called workspaces to work on the front and back end.</p>
<h2><a class="header" href="#creating-your-initial-project" id="creating-your-initial-project">Creating your initial project</a></h2>
<p>First, create a directory then create a Cargo.toml file in it:</p>
<pre><code>mkdir -p ~/Projects/weblearn
cd ~/Projects/weblearn
touch Cargo.toml
</code></pre>
<p>The Cargo.toml file will need to be edited to look something like this:</p>
<pre><code class="language-toml">[workspace]

members = [
  &quot;backend&quot;,
  &quot;frontend&quot;
]
</code></pre>
<h2><a class="header" href="#generating-the-machine-learning-project" id="generating-the-machine-learning-project">Generating the machine learning project</a></h2>
<p>Since this is a (partially) isomorphic web projectrunning rust on the backend, and a combined
webassembly/typescript front end (and a forthcoming rust IoT microcontroller sensor), we need a way
to generate the the frontend project so that our rust code compiles to wasm, and all the glue clode
to call to/from javascript functions can be done.</p>
<p>To set up the front end project you can go into your weblearn directory and run
the following:</p>
<pre><code class="language-bash">npm init rust-webpack mllib
</code></pre>
<p>This will generate a wasmpack style project that contains the code necessary for a combined rust and
javascript project.  Later, we will go into what files were generated, and how to build this
workspace, but for now, you can browse this new frontend directory.</p>
<h3><a class="header" href="#using-typescript" id="using-typescript">Using typescript</a></h3>
<p>However, we are using rust, so why would we want to use javascript with it's dynamic types? We will
enhance our project build code by allowing us to use typescript.</p>
<p>We will use a project called create-base-ts for this purpose.  It will scaffold a project for use
with typescript.</p>
<pre><code class="language-sh">npm init base-ts frontend
npx tsc
</code></pre>
<p>The above commands will install typescript as a dev-dependency in our package.json file, and the
<code>npx tsc</code> command will build our base project</p>
<p>We will tweak some of the configuration parameters later, once we build the project for the first
time.</p>
<h2><a class="header" href="#generating-the-backend-project" id="generating-the-backend-project">Generating the backend project</a></h2>
<p>The backend will be a typical rust web server using actix-web, so we can just use cargo for this:</p>
<pre><code class="language-bash">cd /path/to/weblearn
cargo new backend
</code></pre>
<h1><a class="header" href="#using-kubernetes-for-testing-and-deployment" id="using-kubernetes-for-testing-and-deployment">Using kubernetes for testing and deployment</a></h1>
<p>Ultimately we are creating a Google Cloud Product, and therefore we need to create a kubernetes
project.  As we develop the project and have something to actually test and deploy, we will go into
more detail.</p>
<p>However, we can go over the actual build container.  At the beginning of the chapter, we went over
how to setup all your local development dependencies.  However, we also need a reproducible way to
build our project.  While installing local tools is nice, what we really want to do in a production
environment are many things:</p>
<ul>
<li>Automate the process of building all the artifacts our project needs</li>
<li>As the artifacts are built, unit test them</li>
<li>Once all the artifacts have been built, run integration tests</li>
<li>If all the unit and integration tests pass, create a docker image</li>
<li>Build your Kubernetes Objects (deployments, services, etc) locally</li>
<li>Run minikube and apply all your config files to run your app</li>
<li>Run end to end tests against the app</li>
<li>If the tests pass
<ul>
<li>Tag the build(s) of your image(s)</li>
<li>push the image to a container repo like docker hub or GCR</li>
</ul>
</li>
<li>Tell GCP to use the latest images and reploy</li>
</ul>
<p>Yes, that's a rather large set of things to do!!  This is called CD or continuous deployment.  This
is slightly different from CI which stands for continuous integration.  The main difference is that
the latter will actually push out the end application/project to a public release, whereas the
former is more about building and testing the artifacts, but not necessarily pushing the artifact to
deployment.</p>
<p>Where does kubernetes fit in?</p>
<h2><a class="header" href="#why-kubernetes" id="why-kubernetes">Why kubernetes?</a></h2>
<p>We want a way to make reproducible builds.  In the olden days, developers would have their local
build environments, which often was some configuration of an IDE.  When the developer was done with
their feature or bug fix, they would click some button on their IDE to build the application, and
maybe they might run some tests (yeah, this was before TDD, BDD, CI, etc).  Assuming it looked good,
said developer of yore would make a CVS or perforce commit and announce to all the coworkers that
new source code was ready.</p>
<p>Very often, a coworker would checkout a copy of the new source code, and lo and behold, he couldn't
even get the project to build!  What trickery was this?  Were gremlins sabotaging code in the
ancient CVS revision control system?  The fastidious engineer might have compared the source code to
make sure it was indeed correct and identical to what the developer who originally built it
successfully had on his or her system.</p>
<p>Well, the problem was often that one developer's configuration of his build tools was a little bit
different.  Or perhaps the build required configuration files to be present in a particular
location, and in a particular state.  It was also highly likely that the local dependencies on one
developers workstation was different from another.  For you youngsters who have only been
programming a few years, you may have wondered where the terms DLL Hell, Classpath Hell, npm hell
(pre yarn or package-lock.json days) etc all came from.  Well, one of the symptoms of the above
problems is when either your program has some kind of dependency conflict (package A requires
package B of version 1.0, while package C requires package B at version 2.0), or it could also mean
that the dependencies on your system are missing or the incorrect version.</p>
<p>Whole dependency management systems were written to try to tackle this problem.  For example,
pkg-config for C(++) shared libraries/object, ant/maven/gradle/ivy for Java dependency loading and
classpath/modulepath configuration, etc etc.</p>
<p>When I first started learning docker, I first struggled with the concept until I realized it was
just a kind of abstraction around a process which carried around a file system with it.  But I also
tended to think of it in terms of running applications.  Afterall, one of the selling points was
that an image was self-contained: it had all the dependencies and runtimes needed to run the
application.  Ever built a python, java, javascript, etc app at work or school, and wanted to have
other people use it?  Well, first, you had to tell them &quot;oh yeah, before you run my application, you
need to install python.  How do you do that?  Well, first you have to....&quot;.  Now imagine some of
your dependency libraries are tucked away in a private repository.  Like maybe you have JFrog
serving up a private npm, maven, pypi etc repo.  Now you have to tell your users how to access the
private repo.</p>
<p>Ughhh, what a pain.</p>
<p>So that's the first thing that containers solved.  Of course, it's also why we are seeing a
resurgence of &quot;build to native&quot; languages, like rust, go, nim, crystal and even haskell.  To be
honest, I always felt like docker containers were a bit of a hack to get around the popularity of
interpreted languages (and yes, I am looking at you java, your bytecode still needs to be fed into a
JVM to spit out the actual machine code).  But containers still have their uses even with &quot;build to
native&quot; languages.</p>
<p>There are 2 other use cases that come to mind:</p>
<ul>
<li>Creating a container that handles building a project</li>
<li>Applications that require more than just a binary</li>
</ul>
<h3><a class="header" href="#your-build-environment-as-a-container" id="your-build-environment-as-a-container">Your build environment as a container</a></h3>
<p>In order to build a rust project, what do you need?</p>
<ul>
<li>The rustc compiler</li>
<li>Tools like cargo</li>
</ul>
<p>You may think, ha! That's all I need.  But is it?  Some rust libraries link to native libraries.
The most notable example of this is the openssl crate which leverages the system openssl.lib.  Some
crates will also attempt to link or build C code.  In that case, you now need a C(++) compiler and
set of tools like make, autoconf, pkg-config, ld, nm, ar, etc.</p>
<p>Or, what if you have a webassembly project?  Now you need to install wasm-pack (well, technically
you don't, but good luck setting it up manually).  If you have a webassembly project, you will need
npm installed too.  Oops, to install npm, I need node.</p>
<p>Maybe you're getting the picture.  There's a lot of stuff that you have to install and get right.
We can automate this process by creating a Dockerfile that builds our...well, build environment.</p>
<p>Let's do that now by creating a Dockerfile, but we're going to put it somewhere special:</p>
<pre><code class="language-Dockerfile">FROM fedora:31 as builder

RUN dnf update -y \
    &amp;&amp; dnf upgrade -y \
    &amp;&amp; dnf install -y curl openssl-devel \
    &amp;&amp; dnf groupinstall -y &quot;Development Tools&quot; \
    &amp;&amp; dnf groupinstall -y &quot;C Development Tools and Libraries&quot; \
    &amp;&amp; dnf clean all -y \
    &amp;&amp; mkdir -p /apps/vision

# TODO: create a khadga user and run as that user.  We don't need to run as root

# Install rust tools
# Strictly speaking this isn't necessary for runtime.  Adding these will create 
# a container that lets us build khadga
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs &gt; rustup.sh \
    &amp;&amp; sh rustup.sh -y \
    &amp;&amp; source ~/.cargo/env \
    &amp;&amp; rustup update \
    &amp;&amp; cargo install wasm-pack

# Install node tools
RUN curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash
RUN source ~/.bashrc \
    &amp;&amp; nvm install 13 \
    &amp;&amp; nvm use 13 \
    &amp;&amp; mkdir -p /apps/bundle \
    &amp;&amp; mkdir -p /src

# TODO: either clone the remote repo, or copy the entire khadga project over.
# In the &quot;build locally&quot; version, we assume that we've built khadga on our dev machine
# but we could also build it in the docker container itself.  Instead of doing a COPY
# we could do a MOUNT
COPY ./khadga /src/khadga
COPY ./vision /src/vision
COPY ./noesis /src/noesis
COPY ./build-docker.sh /src
WORKDIR /src

# TODO: If we need to publish a new noesis library, we need to 

RUN source ~/.bashrc \
    &amp;&amp; source ~/.cargo/env \
    &amp;&amp; ./build-docker.sh \
    &amp;&amp; ls -al

RUN rm -rf /src

FROM fedora:31

RUN mkdir -p /apps/vision

COPY --from=builder /apps/vision /apps/vision

WORKDIR /apps/vision

CMD [ &quot;./khadga&quot; ]
</code></pre>
<p>We want to put this Dockerfile in a <code>dockers/build</code> folder.  So your folder should look something like
this:</p>
<pre><code class="language-text">khadga/
- docker/
	- build/
		- Dockerfile
- khadga/
- noesis/
- vision/
</code></pre>
<p>We don't actually have any source code yet so we can't run this yet.  But I'll show you how to run
this.</p>
<pre><code class="language-bash">cd /path/to/top-level/khadga
sudo docker build -f ./docker/builder/Dockerfile -t stoner/khadga .
</code></pre>
<p>So for example, if my khadga is in <code>/home/stoner/Projects/khadga</code>, I would do:</p>
<pre><code>cd /home/stoner/Projects/khadga
sudo docker build -f ./docker/builder/Dockerfile -t stoner/khadga .
</code></pre>
<p>Running this command will tell docker to use the special Dockerfile we just created and to tag it
with stoner/khadga.  If you don't use the -f option, docker will look in the current directory for a
Dockerfile.  Since we are going to have another Dockerfile in the root khadga directory, that's why
we created and saved this Dockerfile somewhere special.</p>
<h3><a class="header" href="#what-does-it-do" id="what-does-it-do">What does it do?</a></h3>
<p>Basically the above Dockerfile will create a Fedora31 base image, update it with the latest goodies,
and then install our tooling needed to build all the khadga subprojects (including the khadga
backend, the noesis webrtc wasm library, and the vision front end).</p>
<p>Of note is that we use the <code>FROM &lt;base-image&gt; as &lt;phase-name&gt;</code>.  Usually, when you see the <code>FROM</code>
command in a Dockerfile, you don't see the <code>as</code> part.  We use this when we have a multiphase build.
Notice that further down almost at the bottom, we say again <code>FROM fedora:31</code>.  This means that at this
point docker can throw away the preceeding layers and start with the resulting image as a base
image.  However, docker still &quot;remembers&quot; the old image.  That's why you later see the command:</p>
<pre><code class="language-dockerfile">COPY --from=builder /apps/vision /apps/vision
</code></pre>
<p>The <code>--from=builder</code> part says, &quot;from our previous phase called builder, copy the /apps/vision
directory to our current image's /apps/vision directory.  If we didn't use this phased approach, the
resulting image would have been about 2.6GB in size.  But by using the phased approach, the size was
less than 1/10th the size at 203MB.</p>
<p>The other thing to note is the <code>build-docker.sh</code> script that gets called.  This is what actually
builds the subprojects.  It will look like this:</p>
<pre><code class="language-bash">ls -al
cd noesis
wasm-pack build
if [ &quot;${PUBLISH}&quot; = &quot;true&quot; ]; then
  wasm-pack test --firefox
	echo &quot;Deploying noesis to npm&quot;
	npm login
	wasm-pack publish
fi

cd ../vision
rm -rf node_modules
npm install
npm run clean
npm run build
npx jest

cd ../khadga
cargo build --release
# KHADGA_DEV=true cargo test

# Copy all the artifacts
cd ..
echo &quot;Now in ${PWD}&quot;
ls -al khadga
cp -r vision/dist /apps/vision/dist
cp -r khadga/config /apps/vision/config
cp -r khadga/target/release/khadga /apps/vision
</code></pre>
<p>As we build up our code, we will go into more detail on what's happening here.</p>
<h1><a class="header" href="#running-kubernetes" id="running-kubernetes">Running kubernetes</a></h1>
<p>Here, we will show how to set up minikube and use kubectl</p>
<h2><a class="header" href="#installing-minikube" id="installing-minikube">Installing minikube</a></h2>
<p>You can follow the directions to <a href="https://kubernetes.io/docs/tasks/tools/install-minikube/">install minikube here</a></p>
<h3><a class="header" href="#using-minikube" id="using-minikube">Using minikube</a></h3>
<pre><code class="language-bash">minikube start --vm-driver=kvm2
minikube status
</code></pre>
<h2><a class="header" href="#creating-deployment-files" id="creating-deployment-files">Creating deployment files</a></h2>
<p>TODO: Go over all the deployment files we need</p>
<h2><a class="header" href="#installing-kubectl" id="installing-kubectl">Installing kubectl</a></h2>
<p>You can follow the directions here to <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">install kubectl</a></p>
<h3><a class="header" href="#setting-up-kubectl" id="setting-up-kubectl">Setting up kubectl</a></h3>
<p>To get kubectl to use the minikube k8s enviroment by creating a new namespace, run this command:</p>
<pre><code class="language-bash">kubectl config set-context --namespace=localdev minikube
</code></pre>
<h3><a class="header" href="#kubectl-commands" id="kubectl-commands">Kubectl commands</a></h3>
<p>This command will expose an already running pod named khadga, and attach a LoadBalancer service
with a name of khadga-service</p>
<pre><code class="language-bash">kubectl expose deployment khadga --type=LoadBalancer --name=khadga-service 
</code></pre>
<p>This command uses the kompose file, and will run the get command on everything in the kompose</p>
<pre><code class="language-bash">kubectl get -k . 
</code></pre>
<p>Will display all the services running in the kubernetes environment (for the default namespace)</p>
<pre><code class="language-bash">kubectl get service
kubectl get deployment
kubectl get pod
kubectl get pod -o wide 
</code></pre>
<p>Shows how to delete various kubernetes objects like Deployments or Services</p>
<pre><code class="language-bash">kubectl delete deployment khadga
kubectl delete service khadga-service 
</code></pre>
<p>Uses the kompose file to apply all the config files.  Looks for a kompose file</p>
<pre><code class="language-bash">kubectl apply -k . 
</code></pre>
<p>Creates a new namespace.  Namespaces isolate the kubernetes environment</p>
<pre><code class="language-bash">kubectl create namespace localdev 
</code></pre>
<pre><code class="language-bash">kubectl config get-contexts 
</code></pre>
<h2><a class="header" href="#setting-up-gcloud" id="setting-up-gcloud">Setting up gcloud</a></h2>
<p>You can follow the directions here to <a href="https://cloud.google.com/sdk/install">install the gcloud SDK</a>.</p>
<p>Once the gcloud SDK is installed, you will also need to initialize it.</p>
<pre><code>gcloud init
</code></pre>
<h3><a class="header" href="#kubectl-commands-1" id="kubectl-commands-1">kubectl commands</a></h3>
<p>Allow gcloud to use docker</p>
<pre><code class="language-bash">gcloud auth configure-docker
</code></pre>
<p>To set up auth for logging in, run this command.</p>
<pre><code class="language-bash">gcloud auth login
</code></pre>
<p>To set the project in google cloud to work with, run this command</p>
<pre><code class="language-bash">gcloud config set project khadga-dev
</code></pre>
<p>To show a list of images in GCR run this command, where the argument to repository is the URL for
the GCR repo (eg gcr.io, eu.gcr.io, etc), a slash, and then the name of the project</p>
<pre><code class="language-bash">gcloud container images list --repository=gcr.io/khadga-dev
</code></pre>
<p>To show the tags of an image use this command</p>
<pre><code class="language-bash">gcloud container images list-tags gcr.io/khadga-dev/khadga
</code></pre>
<pre><code class="language-bash">docker-credential-gcloud configure-docker
</code></pre>
<p>To get credentials </p>
<pre><code class="language-bash">gcloud container clusters get-credentials standard-cluster-1 --zone us-central1-a --project khadga-dev
</code></pre>
<h2><a class="header" href="#general-workflow-for-testing-and-deployment" id="general-workflow-for-testing-and-deployment">General workflow for testing and deployment</a></h2>
<ul>
<li>docker build your container images</li>
<li>tag your images</li>
<li>push the images to gcr.io</li>
<li>Update the config file for the updated image tag</li>
</ul>
<h3><a class="header" href="#for-testing" id="for-testing">For testing</a></h3>
<ul>
<li>create a localdev namespace and use it</li>
<li>Create the secret so that localdev knows how to use it</li>
<li>patch the serviceaccount to use the imagePullSecrets key</li>
</ul>
<p>For the first step, you need to create a new namespace if you haven't already:</p>
<pre><code class="language-bash">kubectl create namespace localdev
</code></pre>
<p>If you have run this step before, you don't need to again.  You can go to step 3.</p>
<p>You can either append --namespace=localdev to all kubectl commands, or you can make it your default,
where the final argument is the name of your <code>context</code>.  To view your contexts:</p>
<pre><code class="language-bash">kubectl config get-contexts
</code></pre>
<p>Then to set your namespace to the context you want:</p>
<pre><code class="language-bash">kubectl config set-context --namespace=localdev minikube
</code></pre>
<p>Next, you can set up a new <a href="https://blog.container-solutions.com/using-google-container-registry-with-kubernetes">secret key by following there directions here</a></p>
<p>Then you need to patch your serviceaccount to use the key that you downloaded.</p>
<pre><code class="language-bash">kubectl patch serviceaccount default -p '{&quot;imagePullSecrets&quot;: [{&quot;name&quot;: &quot;gcr-json-key&quot;}]}'
</code></pre>
<h1><a class="header" href="#the-main-client-interface" id="the-main-client-interface">The main client interface</a></h1>
<p>First, let's start off with a very basic webpage.  Our end goal with this app is not to create
something beautiful, but simply as a way to get data from some agent (a human, being, an IoT
sensor, or another remote service for example) so that we can work on this data in real time.</p>
<p>Our initial goal is to provide a user interface for a human user (or some AI agent) to post
messages similiar to slack.  It's sort of half slack/gitter, half webchat in that the messages
should be persistenet and editable, but they should also be seen in a public forum (or privately).</p>
<p>A second goal is to provide video camera access to allow for video using WebRTC.</p>
<p>The SPA running on the users browser has 2 initial services:</p>
<ul>
<li>Collect messages from an agent and do text classification on it</li>
<li>Perform face recognition and eye tracking</li>
</ul>
<h2><a class="header" href="#general-layout" id="general-layout">General Layout</a></h2>
<p>Before we get to actually coding up anything, let's think about what we want to show the user, and
how we want the interface to be presented.</p>
<ul>
<li>Navbar
<ul>
<li>Google Login</li>
<li>Settings for app
<ul>
<li>video/audio enumeration</li>
<li>chat and appearance</li>
</ul>
</li>
</ul>
</li>
<li>Chat messages window
<ul>
<li>Public message window</li>
<li>Message threads</li>
<li>Private message window</li>
</ul>
</li>
<li>Logged in users</li>
<li>Video (Draggable and Resizable div component)</li>
</ul>
<h2><a class="header" href="#state" id="state">State</a></h2>
<p>What are some of the things we need to keep track of for our app?</p>
<ul>
<li>Is user logged in already? (ie, session is current and active?)</li>
<li>What users have connected and logged in that we can chat with?</li>
<li>Do we need to show modal for user to sign up?  login?</li>
<li>Max message/text limit for chat message windows before removing from DOM</li>
<li>Is there a video chat session?</li>
<li>SDP data for webrtc peer connection for both offer and reply</li>
</ul>
<h2><a class="header" href="#navbar" id="navbar">Navbar</a></h2>
<p>TODO: Go over how the navbar is implemented in bulma.</p>
<h2><a class="header" href="#chat-message-window" id="chat-message-window">Chat message window</a></h2>
<p>TODO: Go over how to split up into a main public column, and another column for message threads</p>
<h3><a class="header" href="#public-messages" id="public-messages">Public messages</a></h3>
<p>TODO: Explain what the public messages are vs. threaded</p>
<h3><a class="header" href="#message-threads" id="message-threads">Message threads</a></h3>
<p>TODO: Allow replies to a message that follows that specific message</p>
<h3><a class="header" href="#private-messages" id="private-messages">Private messages</a></h3>
<p>TODO: How do we add new containers for private messages?</p>
<h2><a class="header" href="#logged-in-users" id="logged-in-users">Logged in users</a></h2>
<p>TODO Show logged in users </p>
<h2><a class="header" href="#video" id="video">Video</a></h2>
<h1><a class="header" href="#react-and-state-management" id="react-and-state-management">React and state management</a></h1>
<p>For this application we will be using react and redux for state management on the front end side of
things at least in the beginning.  Once we start getting into tensorflow, we will start using rust
data structures to capture some of the data, however the state of the application itself will be
handled with redux.</p>
<h2><a class="header" href="#why-react" id="why-react">Why react</a></h2>
<p>One could ask why we are using react here.  There are other popular and not so popular front end
frameworks out there including but not limited to angular, vue, </p>
<h2><a class="header" href="#why-redux" id="why-redux">Why redux</a></h2>
<h2><a class="header" href="#hooking-a-component-into-redux" id="hooking-a-component-into-redux">Hooking a component into redux</a></h2>
<ul>
<li>Add a new Action Creator with some new state to pass along</li>
<li>Add a reducer that that does something with the action type and new state</li>
<li>Add the new reducer to the combineReducers function</li>
<li>Add a mapPropsToState on component and only pass the data needed (that the reducer takes)</li>
<li>Add a mapDispatchToState if needed
<ul>
<li>Used if component needs to change state that another component needs to react to</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#navbar-component" id="navbar-component">Navbar component</a></h1>
<h1><a class="header" href="#google-authentication-component" id="google-authentication-component">Google Authentication component</a></h1>
<h1><a class="header" href="#mongo-database" id="mongo-database">Mongo Database</a></h1>
<p>We need a way to store information that the app either needs or collects.  For example, we need to know
information about a user that signs up, and what permissions he or she has.  We also want a way to 
persist information about messages we receive so that we can operate on them later if needed.</p>
<p>In this chapter, we will go over setting up a mongodb database, and in later chapters we will revisit
it to shore up security and create some new indexes to speed up searches.  This chapter will also
go over a docker set up to make it easier to set up our static backend files, and setup up the necessary
networking glue to get our rust actix server and databse to talk to each other</p>
<h1><a class="header" href="#using-docker" id="using-docker">Using Docker</a></h1>
<p>In order to test our new code changes as well as deploy our final app, we need a way to deliver
a usable artifact that we can either run tests against, or actually use in production.</p>
<p>Although rust is very nice in that it produces standalone binaries, our product here is actually a
set of services.  For example, khadga needs a database and we can't stuff a database inside our
binary (well, we <em>could</em>, but where would you persist the data?).  Other parts that probably aren't
good to stuff inside the binary are configuration files.  Many times you want to dynamically
configure how an application runs based on a file that it can read.  If we statically link in the
file to the binary, it's stuck with that configuration.  If you allow your app to read the config
file at runtime, where and how do you bring along the configuration file(s)?</p>
<p>To solve these kinds of problems, we will use docker and docker-compose.  If you are not that
familiar with docker, that's fine.  Here, I will explain what is going on, and why we are doing what
we are doing.</p>
<h2><a class="header" href="#installing-docker" id="installing-docker">Installing docker</a></h2>
<p>Depending on your operating system, this can be a tricky affair, so I will direct you to the docs
on the <a href="https://docs.docker.com/install/">docker site</a>.</p>
<h2><a class="header" href="#creating-a-dockerfile" id="creating-a-dockerfile">Creating a Dockerfile</a></h2>
<p>The Dockerfile will be our recipe to create a container that contains our backend server and the
configuration files that it needs.</p>
<p>First, we create a file named Dockerfile in the root of our project.  It will look like this:</p>
<pre><code class="language-dockerfile">FROM ubuntu:bionic

RUN apt update \
    &amp;&amp; apt upgrade -y \
    &amp;&amp; apt install -y curl \
    &amp;&amp; mkdir -p /apps/vision/dist

# TODO: create a khadga user and run as that user.  We don't need to run as root

# Copy the dist that was generated from wasm-pack and webpack to our working dir
# then, copy the executable to the vision directory.  This is because the binary
# is serving files from ./dist
WORKDIR /apps/vision
COPY vision/dist ./dist
COPY khadga/config ./config
COPY target/debug/khadga .

CMD [ &quot;./khadga&quot; ]
</code></pre>
<h2><a class="header" href="#explanation" id="explanation">Explanation</a></h2>
<p>So what's this Dockerfile file doing?  For those not familiar with docker, the Dockerfile is the
default name for the file that the docker CLI will look for when running certain subcommands like
build.  It is a file that contains instructions for how to build a docker image step-by-step.</p>
<p>As a quick aside, do not confuse docker images, from docker containers.  A container is really a
kind of fancy process with special restrictions.  An image is like an executable binary.  From one
binary, you can launch many processes.  The docker image is the <em>executable</em> that a container is
spawned from.  The command <code>docker ps</code> will list running containers, while <code>docker images</code> will list
docker images on your system.</p>
<p>Each line of code is actually creatig a new layer in a docker image (which is why you frequently see
certains commands like RUN using &amp;&amp; to concatenate commands to a single layer).  This layering is
also important to understand when you make changes to your Dockerfile.  As each command in the
Dockerfile is encountered, docker will create a layer which it caches so that it doesn't need to be
done again.  If you only ever add new steps at the bottom of the Dockerfile, that's fine.  However,
if you change a step at the beginning (for example), all steps after your new change must be
executed again, since the layer system is immutable.  This can increase your build times
significantly.</p>
<h3><a class="header" href="#our-base-image" id="our-base-image">Our base image</a></h3>
<p>So our first step is a <code>FROM</code> command, which basically specifies what base image to use.  Here, we
are saying that the base image we will use is an ubuntu bionic release.  Notice the use of the colon
here.  To the left of the colon is the base image name (ubuntu in this case), and to the right of
the colon is a tag.  The colon and tag name are optional, but if you do not use them, there is
typically a default tag (usually <code>:latest</code>).</p>
<p>What this does is download from the docker hub repository an image named ubuntu, with the tag of
bionic. This is our base image.  From this base image, we will add more to it.</p>
<h3><a class="header" href="#adding-new-components-to-our-base-image" id="adding-new-components-to-our-base-image">Adding new components to our base image</a></h3>
<p>Next, we encounter the <code>RUN</code> command.  <code>RUN</code> takes a shell command and executes it within a docker
daemon (which is actually executing our base image).  If you look at the shell commands it is
running, you can see it is updating the operating system, adding curl and creating some directories.</p>
<h3><a class="header" href="#copying-files-from-dev-machine-to-docker-image" id="copying-files-from-dev-machine-to-docker-image">Copying files from dev machine to docker image</a></h3>
<p>A critical thing to understand in docker is the difference between our development machine and the
docker image itself.  We need to get the files from our dev machine onto the docker image.  Another
important thing to understand is the idea of a context which is like a build directory.</p>
<p>When you actually build your docker image, you specify a build context argument.  For example:</p>
<pre><code class="language-sh">sudo docker build -t &lt;username&gt;&lt;/tag&gt; .
</code></pre>
<p>The . at the end tells docker &quot;use the current directory as the build context&quot;.  The build context
is the point of view from your development machine.  If you use your current directory as your build
context, any <code>COPY</code> operations in the Dockerfile will assume that the source is from that build
context.</p>
<p>For the sake of the example, let's assume that you are currently in <code>/path/to/my-project</code>.  And that
you then run </p>
<p>The <code>WORKDIR</code> command tells the docker daemon &quot;use this directory as our working directory from the
docker image point of view&quot;.  In the Dockerfile, we are using <code>WORKDIR /app/vision</code>.  Any command
that copies files for example, will use this directory as the destination directory by default.</p>
<p>So the next command <code>COPY vision/dist ./dist</code> is basically saying &quot;Copy the files from
${BuildContext}/vision/dist to ${WORKDIR}/dist&quot;.  So, if you set your build context to &quot;.&quot; during
the <code>docker build</code> command, and that you are currently in the <code>/path/to/my-project</code> directory, that
this will copy our project's <code>vision/dist</code> directory to the docker image's <code>/app/vision/dist</code>
directory.</p>
<p>Hopefully the next <code>COPY</code> commands are clear now.  We also copy our local khadga/config on our dev
machine to the image's  /app/vision/config directory.  The last <code>COPY</code> is interesting.  Here, we
will copy the binary generated from cargo (in this case the debug version) to our docker image in
/app/vision.  Eventually, we'll want to somehow dynamically set that based on whether we want to use
the docker container for testing or release it to production.</p>
<h3><a class="header" href="#executing-our-process" id="executing-our-process">Executing our process</a></h3>
<p>A docker container executes what's in the <code>CMD</code> operation.  The first arg is our command or
executable, and subsequent elements in the array are any arguments the executable needs.</p>
<h2><a class="header" href="#setting-up-mongodb-with-docker-compose" id="setting-up-mongodb-with-docker-compose">Setting up mongodb with docker-compose</a></h2>
<p>This chapter is about mongodb, but so far we haven't touched mongodb at all.  Creating the
Dockerfile was necessary however for our next piece, the docker-compose file, which will be
explained in the next section</p>
<h2><a class="header" href="#todo-docker-compose" id="todo-docker-compose">TODO: docker-compose</a></h2>
<p>create mongodb container</p>
<h1><a class="header" href="#todo-schemas-for-data-types" id="todo-schemas-for-data-types">TODO: schemas for data types</a></h1>
<p>Yes, this is mongo, but schemas are not a bad thing.</p>
<h1><a class="header" href="#todo-setup-initial-dbrs-code" id="todo-setup-initial-dbrs-code">TODO: setup initial db.rs code</a></h1>
<h1><a class="header" href="#security" id="security">Security</a></h1>
<h1><a class="header" href="#authenticating-a-user" id="authenticating-a-user">Authenticating a user</a></h1>
<p>For khadga, we will be using the Google OAuth mechanism.</p>
<h2><a class="header" href="#setting-things-up" id="setting-things-up">Setting things up</a></h2>
<p>There are actually 2 parts to this:</p>
<ul>
<li>Setting up a google account with OAuth Credentials</li>
<li>The front end client</li>
</ul>
<h2><a class="header" href="#setting-up-google-account-for-oauth" id="setting-up-google-account-for-oauth">Setting up google account for OAuth</a></h2>
<p>The first thing we will need to do is to set up a google account.  Go to
<a href="https://console.developers.google.com">console.developers.google.com</a> and select or create a project.  Since the UI is always
changing, it's hard to say what to look for, but currently, in the left hand sidebar, there is a
link that says <code>Credentials</code>.</p>
<p>If you click on <code>Credentials</code>, a new layout appears that shows your current credentials for your
project:</p>
<ul>
<li>API Keys</li>
<li>OAuth2 credentials</li>
<li>Service Accounts</li>
</ul>
<p>At the top, there is a button to <code>+ Create Credentials</code>.  In the drop down that appears, select the
OAuth client ID option.  In the next screen, you can select <code>Web Option</code>.  A new section appears and
you can optionally give it a name.</p>
<p>There will also be a field that specifies authorized javascript origins.  For demo purposes, we can
put in <code>http://localhost:7001</code> which is where our khadga backend, and therefore where our web page's
<code>window.location</code> will be.</p>
<h2><a class="header" href="#setting-up-the-front-end-client" id="setting-up-the-front-end-client">Setting up the front end client</a></h2>
<p>The first thing we need to do is load the javascript.  Unfortunately, google does not release an npm
package, so we need to load this in a <code>&lt;script&gt;</code> tag in our index.html.</p>
<pre><code class="language-html">  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;title&gt;Grid test web app!&lt;/title&gt;
    &lt;script defer src=&quot;https://use.fontawesome.com/releases/v5.3.1/js/all.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://apis.google.com/js/api.js&quot;&gt;&lt;/script&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt;&lt;link&gt;
  &lt;/head&gt;
</code></pre>
<p>Once we do this, we will have access to the <code>gapi</code> object from our window.navigator.  Since we are
using typescript, adding objects to the global <code>window</code> object is a bit hacky.  We will do a simple
approach which is not type-safe, and then improve on it later.</p>
<pre><code class="language-javascript">function latestName(conn, user) {
	let baseName = user;
	let re = new RegExp(`${baseName}-(\\d+)`);
	let index = 0;
	for (let name of conn) {
		if (name === baseName) {
      console.log(`${name} in list matches current of ${baseName}`)
			let matched = name.match(re);
			if (matched) {
				index = parseInt(matched[1]) + 1;
				console.log(matched);
				console.log(`Got match, index is ${index}`);
				baseName = baseName.replace(/\d+/, `${index}`);
			} else {
				index += 1;
				baseName = `${baseName}-${index}`;
			}
		} else {
      console.log(`${name} does not equal ${baseName}`)
		}
		console.log(`baseName is now ${baseName}`)
	}
	return baseName;
}

latestName([&quot;sean&quot;, &quot;sean-1&quot;, &quot;sean-2&quot;], &quot;sean&quot;)
</code></pre>
<h1><a class="header" href="#letencrypt-tls-certs" id="letencrypt-tls-certs">Letencrypt TLS certs</a></h1>
<p>If you have an https server, you'll need a real TLS server.  Creating self-signed certs is ok for
testing purposes, but even then, unless you have good automation and CI/CD pipelines, there's a
danger of accidentally deploying a server with a self-signed cert to production.</p>
<p>Here, we will talk about how to create a Letsencrypt TLS cert that you can use for the khadga
backend</p>
<h2><a class="header" href="#certbot" id="certbot">Certbot</a></h2>
<p>TODO: Show how to use certbot and docker to autogenerate and autorenew a TLS cert that we can deploy</p>
<h1><a class="header" href="#the-backend" id="the-backend">The backend</a></h1>
<p>Even single page apps have to get downloaded to the user's browser somehow.  This chapter will talk
about how to set up a web server written in the warp framework for rust.</p>
<p>We will also go over the endpoints we'd like to establish, although in later chapters, we will flesh
out some additional endpoints we would like to make.</p>
<h2><a class="header" href="#warp" id="warp">Warp</a></h2>
<p>TODO: Creating https in warp</p>
<p>Discuss nginx load balancer as an option</p>
<h1><a class="header" href="#authentication" id="authentication">Authentication</a></h1>
<p>We don't just want anyone to come in and use our service.  We could allow guests to access some
parts of the system, but not everything.  The first step is having a user sign up and register
themselves to the service.</p>
<p>Once a user is registered, we need a way to validate that the entity accessing the service, is who
they actually say they are.  This is authentication.  This is not to be confused with authorization,
which means that we have know you are John Doe, but we need to know what permissions John Doe has to
our system.</p>
<h2><a class="header" href="#classic-database-authentication" id="classic-database-authentication">Classic database authentication</a></h2>
<p>We will be implementing a classic password + database security.  While perhaps not the best system,
we can later augment this.</p>
<p>TODO: Discuss how to send data from web page, to backend, and then to the mongodb.</p>
<h2><a class="header" href="#2fa" id="2fa">2FA</a></h2>
<p>TODO: using 2FA or TPM</p>
<p>Talk about stragies for stronger authN</p>
<h2><a class="header" href="#oauth" id="oauth">Oauth</a></h2>
<p>TODO: Talk about possibly implementing OAuth with google</p>
<h1><a class="header" href="#authorization" id="authorization">Authorization</a></h1>
<p>It's not good enough to authenticate the user is who he or she is, but we also need to restrict
access to service to those who are authorized for those services.</p>
<p>TODO:  Describe JWT tokens and how to use rust to generate them, and to have the khadga backend make
use of them.</p>
<h1><a class="header" href="#backend-server" id="backend-server">Backend Server</a></h1>
<p>We need a server to supply a couple of services we need:</p>
<ul>
<li>Authentication service to provide JWT tokens</li>
<li>Signaling service so peers can send WebRTC media to each other</li>
<li>Websocket service for chatting</li>
</ul>
<h1><a class="header" href="#noesis" id="noesis">Noesis</a></h1>
<p>Noesis in Greek means, &quot;insight&quot;, &quot;to understand&quot; or &quot;to see&quot;.  I thought it was a good name for a
webassembly module intended to grab data from different sources and as a helper for tensorflowjs.</p>
<h2><a class="header" href="#what-it-does" id="what-it-does">What it does</a></h2>
<p>Noesis will be a slowly growing webassembly module that will do the following:</p>
<ul>
<li>WebRTC handling, including getting MediaStreams and MediaDevices</li>
<li>Tensor'izing data from websockets</li>
<li>Tensor'izing data from MediaStreams</li>
</ul>
<h2><a class="header" href="#how-it-works" id="how-it-works">How it works</a></h2>
<p>TODO: Explain how to use wasm-pack, wasm-bindgen, web-sys and js-sys</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
