<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learn how to create a web app with rust and webassembly</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="expanded "><a href="chapter2/chapter_2.html"><strong aria-hidden="true">2.</strong> Setup</a></li><li><ol class="section"><li class="expanded "><a href="chapter2/chapter_2_1.html"><strong aria-hidden="true">2.1.</strong> Setting up the Project</a></li></ol></li><li class="expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Frontend Navbar</a></li><li><ol class="section"><li class="expanded "><a href="chapter3/chapter_3_1.html"><strong aria-hidden="true">3.1.</strong> React and State management</a></li><li class="expanded "><a href="chapter3/chapter_3_2.html"><strong aria-hidden="true">3.2.</strong> Navbar component</a></li><li class="expanded "><a href="chapter3/chapter_3_3.html"><strong aria-hidden="true">3.3.</strong> Login component</a></li><li class="expanded "><a href="chapter3/chapter_3_4.html"><strong aria-hidden="true">3.4.</strong> Registration component</a></li></ol></li><li class="expanded "><a href="chapter4/chapter_4.html"><strong aria-hidden="true">4.</strong> Mongo Database</a></li><li><ol class="section"><li class="expanded "><a href="chapter4/chapter_4_1.html"><strong aria-hidden="true">4.1.</strong> Using docker</a></li><li class="expanded "><a href="chapter4/chapter_4_2_md.html"><strong aria-hidden="true">4.2.</strong> Docker copose</a></li><li class="expanded "><a href="chapter4/chapter_4_3.html"><strong aria-hidden="true">4.3.</strong> Schemas</a></li><li class="expanded "><a href="chapter4/chapter_4_4.html"><strong aria-hidden="true">4.4.</strong> Mongodb driver</a></li></ol></li><li class="expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Security</a></li><li><ol class="section"><li class="expanded "><a href="chapter5/chapter_5_1.html"><strong aria-hidden="true">5.1.</strong> Registering a user</a></li><li class="expanded "><a href="chapter5/chapter_5_2.html"><strong aria-hidden="true">5.2.</strong> TLS Certs</a></li><li class="expanded "><a href="chapter5/chapter_5_3.html"><strong aria-hidden="true">5.3.</strong> HTTPS in warp</a></li><li class="expanded "><a href="chapter5/chapter_5_4.html"><strong aria-hidden="true">5.4.</strong> Authentication</a></li><li class="expanded "><a href="chapter5/chapter_5_5.html"><strong aria-hidden="true">5.5.</strong> Authorization and JWTs</a></li></ol></li><li class="expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> Backend Server</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Learn how to create a web app with rust and webassembly</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction-to-khadga" id="introduction-to-khadga">Introduction to khadga</a></h1>
<p>This book is a small guide on how to create a web application using react, typescript, and
webassembly generated from rust.  It will take you from knowing nothing about how to create wasm to
how to generate both the front and back end code for your app.</p>
<p>The application that is generated here is a small chat application that will set up WebSocket
connections between two or more clients and the central web server.</p>
<p>If you're wondering where the name khadga comes from, it's a Sanskrit word meaning sword.  It is
often referred to in spiritual or mystical concepts as the sword that cuts away illusion.</p>
<h2><a class="header" href="#what-you-will-learn" id="what-you-will-learn">What you will learn</a></h2>
<p>This guide will walk you through everything required to develop, test and deploy both the front and
backend application. This includes:</p>
<ul>
<li>How to write an asynchronous web server using rust's warp framework</li>
<li>How to use wasm-bindgen, web-sys and js-sys crates to create a wasm npm module</li>
<li>How to serve your single page app from the async web server</li>
<li>How to deploy your app to Openshift Online using docker and source-2-image</li>
<li>How to set up unit and integration tests for the front and back end</li>
<li>How to set up a CI pipeline between your deployment and your tests</li>
</ul>
<h3><a class="header" href="#what-the-app-does" id="what-the-app-does">What the app does</a></h3>
<p>We will build the functionality of the app slowly in order to make it useful early on, but to build
up functionality as we go.</p>
<ul>
<li>Chat application</li>
<li>WebRTC for cam-to-cam video conferencing</li>
<li>Video recognition</li>
</ul>
<p>First, we will start with a relatively simple chat application.  It will also cover things like
setting up a database of users and saved chat history.  It will also showcase how to do user
authentication and authorization.</p>
<p>Second, we will enhance the app so that it will do video as well as text based chatting.  In this
step, we will add a signaling service to the bacnd, so peers can find one another.  Chats can either
be saved locally or stored on the discovery server. This step will also show how to encrypt the
streams for end to end encryption.</p>
<p>Lastly, we will build on the video streams enabled by the WebRTC to do image recognition.  We will
use this as a project to detect faces that are displayed and see if it is a known user.</p>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<p>This chapter will cover how to scaffold and generate the initial wasm-pack code as well as a basic
asynchronous web server but it assumed that the reader is already familiar with:</p>
<ul>
<li>basic rust</li>
<li>basic html</li>
<li>basic css</li>
<li>basics of docker</li>
</ul>
<p>The reader's rust skills should be at a basic level.  One of the goals of the book is to explain
some of the more tricky rust concepts (or at least tricky to the author).  A basic understanding of
rust ownership and lifetimes, and how closures work will be required.  Understanding how Traits
work, especially AsRef and From/Into will also be useful. The async/await portions will be described
in detail however.</p>
<p>The reader should have a basic level of HTML5 understanding.  This includes knowing what the DOM is
and the basics of common tags.  Most of the front end will be calling the web-sys bindings to the
Web APIs, so it is useful but not required to know javascript.  Because we are creating a single
page app, knowledge of CSS will be useful, as the book will not spend a lot of time explaining much
of the CSS content.</p>
<p>For deployment, we will be using Openshift Online.  There is a free tier available and you can use
this to deploy the application.  In order to get the server to the cloud, we will need to create a
container and therefore a docker image. This will not be advanced, but there will not be a lot of
explanation of what the docker file does.</p>
<h2><a class="header" href="#caveats" id="caveats">Caveats</a></h2>
<p>The biggest caveat is the author is new to this himself.  The decision to write the book was to help
others so they do not have to learn the hard way like the author did.  Also, the author is at a
basic to intermediate level understanding of rust.  There could very well be a better way to write
the code and if so, please make a PR and contribute!</p>
<p>The second caveat was that this project made an opinionated stance on the technology used.  First
and foremost was the desire to use the new async/await syntax.  This lead to several <em>problems</em>.
For example, since async/await is still new, documentation is scarce.</p>
<h3><a class="header" href="#why-not-yew" id="why-not-yew">Why not yew?</a></h3>
<p>Seasoned developers might ask why <a href="https://github.com/yewstack/yew">yew</a> was not used for this project.  The simple answer here
is that there was a desire to use wasm-bindgen, web-sys and js-sys crates to create the app.</p>
<p>The author has no working knowledge of yew, and it was considered initially.  Afterall, it seems to
tick off a lot of the right boxes:</p>
<ul>
<li>Built in virtual DOM</li>
<li>Macros to generate JSX like code</li>
<li>Concurrency</li>
<li>Safe state management</li>
</ul>
<p>However, yew is built on a crate called stdweb instead of wasm-bindgen, web-sys and js-sys.  The
main difference is that those libraries are created and maintained by the official Web Assembly
Working Group.  It will therefore be more up to date and have &quot;official&quot; support.  It was also
designed to be language agnostic and the bindings are auto-generated from the WebIDL schema.</p>
<h3><a class="header" href="#why-not-percy" id="why-not-percy">Why not percy?</a></h3>
<p>There is another framework that looked promising called <a href="https://github.com/chinedufn/percy">percy</a>.  It also has a virtual DOM
and macro generator to create some JSX-like code. Unlike yew, it is using wasm-bindgen and web-sys
and js-sys crates. The problem with percy is that because of some of the macros, it required a
nightly toolchain.</p>
<p>Although nightly is great for individual learning and experimentation, it's not the best for
teaching others.  The brittleness of nightly means that what may compile one day for one person may
not compile for another person (or the same person!) on another day.  It can also be hard sometimes
to find a nightly build that allows all dependency crates to be built successfully.</p>
<h3><a class="header" href="#why-not-seed" id="why-not-seed">Why not seed?</a></h3>
<p>I discovered <a href="https://seed-rs.org/">seed</a> very recently, and while it seems to fit the bill for writing the entire
application in rust, upon some consideration, I felt that it would be more beneficial to write the
front end in react and typescript, and use wasm only for speed (or safety) sensitive areas of the
code.</p>
<p>This also has the advantage of being able to slowly convert existing applications to use wasm,
rather than have an all-in-one greenfield project created from scratch.</p>
<h1><a class="header" href="#setup" id="setup">Setup</a></h1>
<p>Now that you know what you will be building, let's get started setting up all the development
dependencies.  You'll need to have rust and npm set up as well as a few cargo tools</p>
<ul>
<li>rustup</li>
<li>npm (recommend using nvm)</li>
<li>cargo-generate</li>
<li>cargo-edit</li>
</ul>
<p>You can also checkout the github repository of khadga itself</p>
<h2><a class="header" href="#installing-rustup" id="installing-rustup">Installing rustup</a></h2>
<p>If you haven't already, install <a href="https://rustup.rs/">rustup</a> by following the directions.  If you
already have rustup installed, make sure it's at the latest and greatest (at the time of writing,
this is 1.40).  To update your rustup, do</p>
<pre><code class="language-bash">rustup self update
rustup update
</code></pre>
<p>Next, you need to set up the wasm32 target so that rustc can compile to the wasm32-unknown-unknown
target triple</p>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<h3><a class="header" href="#other-rustup-goodies" id="other-rustup-goodies">Other rustup goodies</a></h3>
<p>While we are configuring rustup, we can install some other components as well</p>
<pre><code class="language-bash">rustup component add llvm-tools-preview rustfmt clippy rls rust-analysis
</code></pre>
<h3><a class="header" href="#c-toolchain" id="c-toolchain">C(++) toolchain</a></h3>
<p>Some rust crates have native dependencies.  For example the openssl crate will use and link to a
native ssl lib on your system.  Because of this, it's sometimes necessary to have a C(++) toolchain
on your system as well.</p>
<p>It's beyond the scope of this book to show how to do this, since each operating system will do it a
bit differently.  For Windows, it's recommended to install one of the free Visual Studio C++
compilers.  For linux debian based distributions, you can usually get away with something like this:</p>
<pre><code class="language-sh">sudo apt install build-essential
</code></pre>
<p>For Fedora, you can do this:</p>
<pre><code class="language-sh">sudo dnf groupinstall &quot;Development Tools&quot;
sudo dnf groupinstall &quot;C Development Tools and Libraries&quot;
</code></pre>
<h2><a class="header" href="#adding-cargo-tools" id="adding-cargo-tools">Adding cargo tools</a></h2>
<p>Although cargo is automatically installed by rustup, we are going to install some cargo additions.</p>
<pre><code class="language-sh">cargo install cargo-generate cargo-edit
</code></pre>
<p>cargo-generate is a tool that will auto generate a template for you (and is used by wasm-pack) and
cargo-edit is a nice little cargo command that lets you add a dependency to your Cargo.toml (think
npm install).</p>
<h2><a class="header" href="#setting-up-vscode" id="setting-up-vscode">Setting up vscode</a></h2>
<p>We'll be using the Microsoft VS Code editor, since it has good support for rust and is relatively
lightweight.  Because we are using some bleeding edge crates, we'll also have to specify some
additional configuration in the rust extension.</p>
<p>First, install <a href="https://code.visualstudio.com/">vs code</a> itself.  Once you have code installed, we need to install
the rust extension. You can either do this from the command line, or through VS Code itself.</p>
<pre><code class="language-sh">code --install-extension rust-lang.rust
</code></pre>
<p>While we are installing extensions, let's install a couple others that will make our lives easier:</p>
<ul>
<li>crates: To make it easier to see what the latest (stable) crate version is at</li>
<li>lldb debugger: So we can debug our code</li>
<li>toml: so we can get syntax highlights and coloring for our toml files</li>
</ul>
<pre><code>code --install-extension bungcip.better-toml
code --install-extension vadimcn.vscode-lldb
code --install-extension serayuzgur.crates
</code></pre>
<h2><a class="header" href="#install-npm-and-nvm" id="install-npm-and-nvm">Install npm (and nvm)</a></h2>
<p>Since we are building a front end web app, we will be making use of some npm tools.  It's highly
recommended that you use the Node Version Manager (nvm) for this if you are on linux or MacOS.  For
windows users, you'll probably need to use chocolatey to install node (and npm).</p>
<h3><a class="header" href="#linux-and-macos" id="linux-and-macos">linux and macos</a></h3>
<p>For linux and macos users, you can follow the directions here to install nvm.  Once you install nvm,
you'll need to actually install a node version.</p>
<pre><code class="language-bash">nvm install 13
nvm use 13
</code></pre>
<h3><a class="header" href="#windows" id="windows">Windows</a></h3>
<p>For windows users, if you don't have <a href="https://chocolatey.org/install">chocolatey</a> already, install that.  Then you can
install node (and therefore npm) with:</p>
<pre><code class="language-bash">choco install nodejs  # make sure you run from an elevated command/powershell shell
</code></pre>
<h2><a class="header" href="#installing-wasm-pack" id="installing-wasm-pack">Installing wasm-pack</a></h2>
<p>For this project, we will be using wasm-pack which will generate a template for us, as well as set
up a webpack config which will automatically compile our rust code to wasm.</p>
<p>You can install <a href="https://rustwasm.github.io/wasm-pack/">wasm-pack</a> here.</p>
<p>Alternatively, you can install wasm-pack via cargo:</p>
<pre><code class="language-sh">cargo install wasm-pack
</code></pre>
<h1><a class="header" href="#setting-up-the-project" id="setting-up-the-project">Setting up the project</a></h1>
<p>Now that we have all our dependencies out of the way, it's time to actually create our project.
Unlike many rust projects you will see on tutorials, we are going to have a fairly advanced cargo
setup.  We will be using a feature of cargo called workspaces to work on the front and back end.</p>
<h2><a class="header" href="#creating-your-initial-project" id="creating-your-initial-project">Creating your initial project</a></h2>
<p>First, create a directory then create a Cargo.toml file in it:</p>
<pre><code>mkdir -p ~/Projects/weblearn
cd ~/Projects/weblearn
touch Cargo.toml
</code></pre>
<p>The Cargo.toml file will need to be edited to look something like this:</p>
<pre><code class="language-toml">[workspace]

members = [
  &quot;backend&quot;,
  &quot;frontend&quot;
]
</code></pre>
<h2><a class="header" href="#generating-the-machine-learning-project" id="generating-the-machine-learning-project">Generating the machine learning project</a></h2>
<p>Since this is a (partially) isomorphic web projectrunning rust on the backend, and a combined
webassembly/typescript front end (and a forthcoming rust IoT microcontroller sensor), we need a way
to generate the the frontend project so that our rust code compiles to wasm, and all the glue clode
to call to/from javascript functions can be done.</p>
<p>To set up the front end project you can go into your weblearn directory and run
the following:</p>
<pre><code class="language-bash">npm init rust-webpack mllib
</code></pre>
<p>This will generate a wasmpack style project that contains the code necessary for a combined rust and
javascript project.  Later, we will go into what files were generated, and how to build this
workspace, but for now, you can browse this new frontend directory.</p>
<h3><a class="header" href="#using-typescript" id="using-typescript">Using typescript</a></h3>
<p>However, we are using rust, so why would we want to use javascript with it's dynamic types? We will
enhance our project build code by allowing us to use typescript.</p>
<p>We will use a project called create-base-ts for this purpose.  It will scaffold a project for use
with typescript.</p>
<pre><code class="language-sh">npm init base-ts frontend
npx tsc
</code></pre>
<p>The above commands will install typescript as a dev-dependency in our package.json file, and the
<code>npx tsc</code> command will build our base project</p>
<p>We will tweak some of the configuration parameters later, once we build the project for the first
time.</p>
<h2><a class="header" href="#generating-the-backend-project" id="generating-the-backend-project">Generating the backend project</a></h2>
<p>The backend will be a typical rust web server using actix-web, so we can just use cargo for this:</p>
<pre><code class="language-bash">cd /path/to/weblearn
cargo new backend
</code></pre>
<h1><a class="header" href="#frontend-navbar" id="frontend-navbar">Frontend Navbar</a></h1>
<h1><a class="header" href="#todo-aside-on-react-and-state-management-for-this-app" id="todo-aside-on-react-and-state-management-for-this-app">TODO: Aside on react and state management for this app</a></h1>
<h1><a class="header" href="#todo-navbar-component" id="todo-navbar-component">TODO: Navbar component</a></h1>
<h1><a class="header" href="#todo-registration-component" id="todo-registration-component">TODO: Registration component</a></h1>
<h1><a class="header" href="#todo-login-modal-component" id="todo-login-modal-component">TODO: Login modal component</a></h1>
<h1><a class="header" href="#mongo-database" id="mongo-database">Mongo Database</a></h1>
<p>We need a way to store information that the app either needs or collects.  For example, we need to know
information about a user that signs up, and what permissions he or she has.  We also want a way to 
persist information about messages we receive so that we can operate on them later if needed.</p>
<p>In this chapter, we will go over setting up a mongodb database, and in later chapters we will revisit
it to shore up security and create some new indexes to speed up searches.  This chapter will also
go over a docker set up to make it easier to set up our static backend files, and setup up the necessary
networking glue to get our rust actix server and databse to talk to each other</p>
<h1><a class="header" href="#using-docker" id="using-docker">Using Docker</a></h1>
<p>In order to test our new code changes as well as deploy our final app, we need a way to deliver
a usable artifact that we can either run tests against, or actually use in production.</p>
<p>Although rust is very nice in that it produces standalone binaries, our product here is actually a
set of services.  For example, khadga needs a database and we can't stuff a database inside our
binary (well, we <em>could</em>, but where would you persist the data?).  Other parts that probably aren't
good to stuff inside the binary are configuration files.  Many times you want to dynamically
configure how an application runs based on a file that it can read.  If we statically link in the
file to the binary, it's stuck with that configuration.  If you allow your app to read the config
file at runtime, where and how do you bring along the configuration file(s)?</p>
<p>To solve these kinds of problems, we will use docker and docker-compose.  If you are not that
familiar with docker, that's fine.  Here, I will explain what is going on, and why we are doing what
we are doing.</p>
<h2><a class="header" href="#installing-docker" id="installing-docker">Installing docker</a></h2>
<p>Depending on your operating system, this can be a tricky affair, so I will direct you to the docs
on the <a href="https://docs.docker.com/install/">docker site</a>.</p>
<h2><a class="header" href="#creating-a-dockerfile" id="creating-a-dockerfile">Creating a Dockerfile</a></h2>
<p>The Dockerfile will be our recipe to create a container that contains our backend server and the
configuration files that it needs.</p>
<p>First, we create a file named Dockerfile in the root of our project.  It will look like this:</p>
<pre><code class="language-dockerfile">FROM ubuntu:bionic

RUN apt update \
    &amp;&amp; apt upgrade -y \
    &amp;&amp; apt install -y curl \
    &amp;&amp; mkdir -p /apps/vision/dist

# TODO: create a khadga user and run as that user.  We don't need to run as root

# Copy the dist that was generated from wasm-pack and webpack to our working dir
# then, copy the executable to the vision directory.  This is because the binary
# is serving files from ./dist
WORKDIR /apps/vision
COPY vision/dist ./dist
COPY khadga/config ./config
COPY target/debug/khadga .

CMD [ &quot;./khadga&quot; ]
</code></pre>
<h2><a class="header" href="#explanation" id="explanation">Explanation</a></h2>
<p>So what's this Dockerfile file doing?  For those not familiar with docker, the Dockerfile is the
default name for the file that the docker CLI will look for when running certain subcommands like
build.  It is a file that contains instructions for how to build a docker image step-by-step.</p>
<p>As a quick aside, do not confuse docker images, from docker containers.  A container is really a
kind of fancy process with special restrictions.  An image is like an executable binary.  From one
binary, you can launch many processes.  The docker image is the <em>executable</em> that a container is
spawned from.  The command <code>docker ps</code> will list running containers, while <code>docker images</code> will list
docker images on your system.</p>
<p>Each line of code is actually creatig a new layer in a docker image (which is why you frequently see
certains commands like RUN using &amp;&amp; to concatenate commands to a single layer).  This layering is
also important to understand when you make changes to your Dockerfile.  As each command in the
Dockerfile is encountered, docker will create a layer which it caches so that it doesn't need to be
done again.  If you only ever add new steps at the bottom of the Dockerfile, that's fine.  However,
if you change a step at the beginning (for example), all steps after your new change must be
executed again, since the layer system is immutable.  This can increase your build times
significantly.</p>
<h3><a class="header" href="#our-base-image" id="our-base-image">Our base image</a></h3>
<p>So our first step is a <code>FROM</code> command, which basically specifies what base image to use.  Here, we
are saying that the base image we will use is an ubuntu bionic release.  Notice the use of the colon
here.  To the left of the colon is the base image name (ubuntu in this case), and to the right of
the colon is a tag.  The colon and tag name are optional, but if you do not use them, there is
typically a default tag (usually <code>:latest</code>).</p>
<p>What this does is download from the docker hub repository an image named ubuntu, with the tag of
bionic. This is our base image.  From this base image, we will add more to it.</p>
<h3><a class="header" href="#adding-new-components-to-our-base-image" id="adding-new-components-to-our-base-image">Adding new components to our base image</a></h3>
<p>Next, we encounter the <code>RUN</code> command.  <code>RUN</code> takes a shell command and executes it within a docker
daemon (which is actually executing our base image).  If you look at the shell commands it is
running, you can see it is updating the operating system, adding curl and creating some directories.</p>
<h3><a class="header" href="#copying-files-from-dev-machine-to-docker-image" id="copying-files-from-dev-machine-to-docker-image">Copying files from dev machine to docker image</a></h3>
<p>A critical thing to understand in docker is the difference between our development machine and the
docker image itself.  We need to get the files from our dev machine onto the docker image.  Another
important thing to understand is the idea of a context which is like a build directory.</p>
<p>When you actually build your docker image, you specify a build context argument.  For example:</p>
<pre><code class="language-sh">sudo docker build -t &lt;username&gt;&lt;/tag&gt; .
</code></pre>
<p>The . at the end tells docker &quot;use the current directory as the build context&quot;.  The build context
is the point of view from your development machine.  If you use your current directory as your build
context, any <code>COPY</code> operations in the Dockerfile will assume that the source is from that build
context.</p>
<p>For the sake of the example, let's assume that you are currently in <code>/path/to/my-project</code>.  And that
you then run </p>
<p>The <code>WORKDIR</code> command tells the docker daemon &quot;use this directory as our working directory from the
docker image point of view&quot;.  In the Dockerfile, we are using <code>WORKDIR /app/vision</code>.  Any command
that copies files for example, will use this directory as the destination directory by default.</p>
<p>So the next command <code>COPY vision/dist ./dist</code> is basically saying &quot;Copy the files from
${BuildContext}/vision/dist to ${WORKDIR}/dist&quot;.  So, if you set your build context to &quot;.&quot; during
the <code>docker build</code> command, and that you are currently in the <code>/path/to/my-project</code> directory, that
this will copy our project's <code>vision/dist</code> directory to the docker image's <code>/app/vision/dist</code>
directory.</p>
<p>Hopefully the next <code>COPY</code> commands are clear now.  We also copy our local khadga/config on our dev
machine to the image's  /app/vision/config directory.  The last <code>COPY</code> is interesting.  Here, we
will copy the binary generated from cargo (in this case the debug version) to our docker image in
/app/vision.  Eventually, we'll want to somehow dynamically set that based on whether we want to use
the docker container for testing or release it to production.</p>
<h3><a class="header" href="#executing-our-process" id="executing-our-process">Executing our process</a></h3>
<p>A docker container executes what's in the <code>CMD</code> operation.  The first arg is our command or
executable, and subsequent elements in the array are any arguments the executable needs.</p>
<h2><a class="header" href="#setting-up-mongodb-with-docker-compose" id="setting-up-mongodb-with-docker-compose">Setting up mongodb with docker-compose</a></h2>
<p>This chapter is about mongodb, but so far we haven't touched mongodb at all.  Creating the
Dockerfile was necessary however for our next piece, the docker-compose file, which will be
explained in the next section</p>
<h2><a class="header" href="#todo-docker-compose" id="todo-docker-compose">TODO: docker-compose</a></h2>
<p>create mongodb container</p>
<h1><a class="header" href="#todo-schemas-for-data-types" id="todo-schemas-for-data-types">TODO: schemas for data types</a></h1>
<p>Yes, this is mongo, but schemas are not a bad thing.</p>
<h1><a class="header" href="#todo-setup-initial-dbrs-code" id="todo-setup-initial-dbrs-code">TODO: setup initial db.rs code</a></h1>
<h1><a class="header" href="#security" id="security">Security</a></h1>
<h1><a class="header" href="#todo-registering-a-user" id="todo-registering-a-user">TODO: Registering a user</a></h1>
<h1><a class="header" href="#todo-tls-certs" id="todo-tls-certs">TODO: TLS certs</a></h1>
<h1><a class="header" href="#todo-creating-https-in-warp" id="todo-creating-https-in-warp">TODO: Creating https in warp</a></h1>
<p>Discuss nginx load balancer as an option</p>
<h1><a class="header" href="#todo-using-2fa-or-tpm" id="todo-using-2fa-or-tpm">TODO: using 2FA or TPM</a></h1>
<p>Talk about stragies for stronger authN</p>
<h1><a class="header" href="#todo-jwt-tokens-and-authz" id="todo-jwt-tokens-and-authz">TODO: JWT tokens and authZ</a></h1>
<h1><a class="header" href="#backend-server" id="backend-server">Backend Server</a></h1>
<p>We need a server to supply a couple of services we need:</p>
<ul>
<li>Registration service for new users</li>
<li>Authentication service to provide JWT tokens</li>
<li>Signaling service so peers can send WebRTC media to each other</li>
<li>Message logging</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
